简介
============================
在我五年级的时候，我和我的小伙伴们有机会进入一个教室，接触一台破旧的[TRS-80s](https://en.wikipedia.org/wiki/TRS-80)机器。为了能够激发我们的兴趣，我们的一位老师为我们演示了一个BASIC写的打印小程序。
由于电脑的音频磁带驱动器坏了，所以我们只能非常小心地听着敲击的声音来输入。这就导致我们更倾向于编写机会寥寥几行的代码，如下：
```
10 PRINT "BOBBY IS RADICAL!!!"
20 GOTO 10
```
即便是这么简单的代码，这个过程对我们来说也是充满挑战。当时我们完全不会编程，所以一个小小的语法错误对我们来时都是一个大灾难。如果程序出错（十分常见的情况），我们就得从头再来。
真正可怕的怪物在后头：一个有好几张布满密密麻麻代码的纸张组成的程序。每次开工之前，我们都要鼓足勇气啊！我们完全不知道这个程序是啥，只知道它的名字是“Tunnels and Trolls”，听起来像一个游戏！还有什么比一个自己手打出来一个游戏更酷的事情吗？！
然而，我们从没有将它完成正常运行起来，过了一年之后，我们搬出了那个教室（后来，当我对BASIC有一点了解的时候，我才意识到那个怪物其实只是一个表的字符产生器）。不过那个怪物还是一直影响着我，从那以后，我们就决定成为一个游戏开发者。

在我13、4岁的时候，我家里买了一台Macintosh，装有QuickBASIC 和THINCK C.基本上，每个暑假假期，我都用它来写游戏代码。自学是一件进步缓慢并且十分痛苦的过程。随着程序的增长，开发变得越来越难。

开始阶段，挑战还只是让程序能够跑起来。然后，问题就变成了如何编写出比我脑子所能够装下理解的更大的程序。这个时候开始，我就从阅读“How to Program in C++”这样的书，转向研究如何组织程序的书籍。

过了几年之后，有个朋友拿着一本 “Design Patterns: Elements of Reusable Object-Oriented Software” 给我看。当时我就惊呆了，这不就是我从青年就开始寻找的书吗？！我坐下来，读了一遍又一遍。当时，我仍然在为我程序增大带来的问题困扰，不过看到别人也面对这样的问题，并且提出了解决方案，这真的是一种解脱了。我终于感觉我是带着一堆武器作战，而不是刺手空拳战斗的了！

在2001年，我得到了梦寐以求的工作：EA的软件工程师。我迫不及待想要看看真正的游戏是如何编写出来的？像Madden Football 这样的大型游戏到底是怎样的架构？ 不同系统间是如何交互的？他们是如何使用单一的代码库，使得游戏却能够在多平台下运行？

打开源代码的时候，是一个令人好奇兴奋而又惊讶的时刻。这里面有非常优秀的代码关于：图形，AI，动画和视觉效果。我们中有人知道如何挤压出CPU的每个周期加以利用。很多我不知道的东西，可能就是这些人在午餐之前做出来的。

然而这些极其优秀的代码背后的架构就并不是那么完美。大家都过度关注特性，却忽略了组织代码的重要性。这些代码在模块间常常都是耦合的。一些新特性出来之后，很多用到它的地方都需要重新修改代码。而我认为，很多工程师，哪怕他们曾经翻开过设计模式这本书，也绝不会违反原子性这一原则。

当然了，其实也并不是这么糟糕。我能想象，这些游戏开发工程师坐在布满白板的象牙塔上，冷静地讨论架构设计几个星期。但是，我看到的代码情况，却是很多代码都是在deadline之前赶出来的。他们已经做了他们能够做的最好的努力，然后我们意识到，他们的更好往往是非常好的。我在编写游戏代码上花的时间越多，我就发现更多隐藏在表面下的优秀的代码。

然而，不幸的是，很多人都看不到这些隐藏的优秀代码。我看着我的同事们努力想要实现一个良好的解决方案，然而其实这些解决方案已经存在代码中了。

>解决以上这个问题，正是本书写作的主要目的。我在自己游戏开发的经验中，找到了一些好的设计模式，并把他们记录在这本书里。这样，我们就可以有更多的时间用在发明新东西上面，而不是用在重复造轮子了。

# 市面上的书籍

有人可能会问，市面上已经存在各种各样的游戏编程类的书。为什么还要写一本？

我看过的大多数的游戏编程书籍，无非就是下面两种类型：

 - 介绍特定领域的书籍：这类书的写作范围一般比较狭小，通常专注于给你在游戏开发某些特定方面的深层次的指导。他们会教你比如：3D图形，实时渲染，物理世界模拟，人工智能或者音频处理方面的知识。这些都是从事游戏开发的工程师在职业发展阶段会碰到的专业技能。
 - 全引擎类的书籍：不同的是，这类书籍试着跨度整个游戏引擎的不同组成部分。他们通常是面向构建一个完整的游戏引擎，来适合于特定类型的游戏，经常举的例子是三维下的第一人称射击游戏。

对于上面的两类书，我个人都非常喜欢。不过我认为他们还是存在一些需要弥补的地方。专业型的书籍教会你如何用代码实现你游戏的功能。但是，你可能知道如何进行物理模拟和渲染，但是，你真的知道如何优雅的组织它们吗？

对于第二类书籍会覆盖上面没有提到的点，但是我经常会发现这些介绍全引擎类的书不是太片面就是太针对于特定流派的游戏。尤其是，随着移动类和休闲类的游戏越来越多的背景下，我们其实是处在一个需要开发各种流派各种类型的游戏的。我们已经不能照搬Quake这一套了。当你的游戏不适合某一个模型的时候，这类单一引擎的书对你的帮助是有限的。

相反的，我尝试介绍一些更为通用的技巧。这本书的每一个章节都是一个独立的观点，并且本书还提供源代码给你学习时使用。这样，你就可以通过混合它们或者匹配它们来达到你想要的最好的游戏效果。

# 如何与设计模式相关

任何编程类的书籍，只要提到了*“模式”*，显然都会联系到经典的设计模式书籍：*Elements of Reusable Object-Oriented Software*，这是由传说中的*Gang of Four*：Erich Gamma, Richard Helm, Ralph Johnson, 和 John Vlissides编写的。

虽然我的这本书叫游戏编程模式，但是，我并不是要证明Gang of Four的理论不适用于游戏开发。相反的：本文的第二章*“再探设计模式”*恰恰是引用了大量设计模式中观点，但是，本文的重点，还是在于如何将它们运用到游戏开发中。

并且，我认为这本书同时也适用于非游戏类的软件开发。所以，我还可以称这本书是*More Design Patterns*，但是我还是觉得把游戏作为例子可以更具吸引力，因为你总不会还想看到一本是是在介绍雇佣记录跟银行账户的吧？

总而言之，本书提到的设计模式同样是在其他软件开发中使用的，我只是认为他们尤其适合与解决在游戏开发中经常遇到的工程性的难题：

 - ***序列：***时间与序列是游戏架构的一个核心任务。事件必须要在特定的时间，特定的情景下发生。
 - ***行为：***由于开发的周期是被极大压缩的，所以一部分程序员需要快速建议并且迭代出一些列丰富的行为，并且要保证没有影响到别的程序员的开发。
 - ***解耦：***当行为定义好后，就要开始交互了。怪兽攻击英雄，药水混合在一起，炸弹把敌人跟朋友都炸死了。这些交互行为，必须要保证不会交织在一起。
 - ***优化：***最后，在游戏中，性能是最关键的环节。游戏开发者在不断的角逐中将会看到到底谁能够最终挤出他们的平台。提高响应性能的技巧，是一个拥有百万销量的游戏盒一个很快被删除并且满是差评的游戏的区别。

# 如何阅读本书
我将这本书分为3个大的章节。第一个是介绍并且组织全书。就是你现在阅读的这节跟下一节。

第二章，是*“再探设计模式”*，这里讲介绍一堆从Gang of Four的那本经典书中提到的理论。每一节中，我都会有自己对于这个模式的思考，并且我是如何应用到游戏开发中的。

最后一个章节是本书的重中之重。提出了13个我认为很有用的设计模式。他们被安排到4个类别：序列模式，行为模式，解耦模式和优化模式。

-  **含义**部分给出了这种设计模式的一个简要描述并告诉你这种模式可以解决那种问题。把这部分放在前面可以帮助你迅速找到可以拓展你的知识的地方。

-  **示例部分**提供了一个将要应用这种设计模式的一个例子。与具体的算法不同，通常，如果不把设计模式用在某个特定的问题上，模式的说明将会很抽象。教授一种设计模式而不用例子来说明类似于教授烘培而不提生面团。这一部分提供了稍后用来烘培的面团。

-  **模式**部分脱离前面所给的例子提取了这个设计模式的精华部分。如果你想要一个枯燥的教科书般的描述的话，就是这一部分了。如果你已经很熟悉这种设计模式了，那么这一部分可以帮助你复习以确保你不会忘记。

-  目前为止，我们仅就一个例子对这个设计模式进行阐述，但是，你怎么知道这种设计模式对解决你的问题会很有效呢？而**用武之地**部分会告诉你什么时候有效，什么时候最好避免使用它。**铭记于心**部分则指出了使用这种设计模式的后果和风险。

-  像我，如果你需要一个具体的例子进行学习**实例代码**部分就是这么一个部分了，通过一步一步地实现这种设计模式，你可以确切地看到模式是如何工作的。

-  设计模式与纯粹的算法不同，它是开放的。每一次你使用某种设计模式，你都可以用不同的方式实现它。下一个部分，**设计与决策**会就这一方面进行讨论并向你展示使用这种模式时可以做某些的选择。

-  为了圆满结束这一部分，有一个简单的部分——**更多请参阅**。它向你展示了与这个设计模式相关的东西并指出了一些现实世界中使用这种设计模式的开源代码。


# 关于示例代码

在本书中示例代码是用C++写的，但是这并不意味着设计模式只能对这种程序设计语言（C++）有效，也不是说用C++比其他语言好。几乎任何语言都可以很好地工作，但是一些设计模式会假设你的语言中有“对象”和“类”。

我选择C++有几个理由。首先在商业游戏中最流行用C++（译者：中国大概是Java？），它是行业语言。更重要的是C/C++式语法在诸如Java，C#，Javascript和其他语言中被广泛应用。在这种状况下，尽管你不了解C++，只要你稍微下点功夫你就可以理解示例代码了。

这本书的目标并不是教你C++，所以实例代码就写的尽可能的简单，这些代码并不代表优秀的C++编程风格。去读出代码所要表现出的想法，而不是去阅读代码是怎样表现这种思想的（译者：大概也就是代码无所谓，思想最重要）。

特别地，示例代码并不是用“现代”风格——C++11或更高——编写的，也没有用到标准库，极少用到模板。希望通过这样做可以让代码尽可能的简单，这将会对那些使用C，Object-C，Java或其他程序设计语言的人更亲近。

为避免在代码上浪费空间（译者：这里指的是纸质书籍的空间浪费，网页上怎么可能有这种问题？！），你已经看到过或是与这种设计模式无关的代码都会被省略，被省略的部分有省略号，还会告诉你省去的代码到哪里去找。

试想这里有一个做某个工作并返回一个值的函数。如果解释设计模式时只用考虑到返回值的时候而不是做了什么的时候，示例代码就会像下面一样：

```cpp
bool update()
{
  // Do work...
  return isDone();
}
```


# 何去何从#

模式是一个在软件开发过程中不断变化，不断扩大的部分。这本书的是从Gang of Four经典理论的分享与讨论中开始的，并且这个讨论、分享的过程还会在本书之外继续进行。

要记住，你才是这个讨论、分享过程的核心。因为当你在开发自己的模式，重定义一些书上提到的模式的时候，实际上你已经在为软件社区贡献了自己的力量。

如果你有任何建议，改进方法，或者反馈，请及时联系我们！
